## 2. 手工调优 
手工调优是通过调优Java虚拟机和垃圾收集从而提升应用程序性能的过程。JVM提供了平台相关的垃圾收集器、堆大小和运行时编译器的默认选项。这些选择可满足不同类型应用程序的需求，同时需要较少的命令行调整。除此之外，基于手工的动态调整可以调整堆的大小，以使应用程序满足指定需求。

### 2.1 垃圾收集器、堆和运行时编译器的默认选择
可以作为服务器的机器通常能够满足以下要求：

- 2个或以上的处理器
- 2GB或更大的物理内存

在服务器上，下面的一些选项通常是默认的：

- 吞吐量垃圾收集器
- 初始堆大小为物理内存的1/64，最大为1GB
- 最大堆大小为物理内存的1/4，最大为1GB
- 服务器运行时编译器

对于64位系统的初始化堆大小和最大堆大小，可以参考[默认堆大小]()和[并行收集器]()。

服务器级计算机的定义适用于所有平台，但运行Windows操作系统版本的32位平台除外。表2-1给出了针对不同平台的运行时编译器的默认选择。

​                                                               表2-1 默认运行时编译器

|     平台      | 操作系统 | 默认选项 | 服务器默认选择 |
| :-----------: | :------: | :------: | :------------: |
|     i586      |  Linux   |  Client  |     Server     |
|     i586      | Windows  |  Client  |     Client     |
| SPARC(64-bit) | Solaris  |  Server  |     Server     |
|  AMD(64-bit)  |  Linux   |  Server  |     Server     |
|  AMD(64-bit)  | Windows  |  Server  |     Server     |

### 2.2 手工调优

对于并行收集器，Java SE提供了两个垃圾收集调优参数用于实现应用程序的指定行为：最大停顿时间目标和应用程序吞吐量目标。详情可以参考[并行收集器]()。(这两个参数在其他收集器中并不存在)注意这两个目标并不总能实现。应用程序需要足够大的堆来存放实时数据。除此之外，堆大小的最小值也会影响这两个目标。

### 2.3 最大停顿时间目标

停顿时间是垃圾收集器停止应用程序并恢复不再使用的空间的持续时间。最大停顿时间目标的目的是限制暂停中的最长时间。垃圾收集器维持平均的停顿时间和该平均值的方差。平均值是从执行开始时获取的，但经过加权后，最近的停顿次数会增加。如果平均时间加上停顿时间的方差大于最大停顿时间目标，则垃圾回收器认为未达到目标。

最大停顿时间目标是通过命令行选项-XX：MaxGCPauseMillis = <nnn>指定的。其指示垃圾收集器要求暂停时间为<nnn>毫秒或更短。垃圾收集器将调整Java堆大小和与垃圾收集相关的其他参数，以使垃圾收集的暂停时间短于<nnn>毫秒。默认情况下，没有最大停顿时间目标。因为这些调整可能导致垃圾回收更频繁地发生，从而降低了应用程序的整体吞吐量。垃圾收集器会尝试在到达吞吐量目标之前达到暂停时间目标，但是在某些情况下无法达到所需的暂停时间目标。

### 2.4 吞吐量目标

吞吐量目标是根据收集垃圾所花费的时间和垃圾收集之外所花费的时间（称为应用程序时间）的比例来衡量的。该目标由命令行选项-XX：GCTimeRatio = <nnn>指定。垃圾回收时间与应用程序时间的比率为1 /（1 + <nnn>）。例如，如果-XX：GCTimeRatio = 19则将目标设置为垃圾收集总时间的1/20或5％。

垃圾收集所花费的时间是年轻代和老年代收集的总时间。如果未达到吞吐量目标，会增加代的大小，以增加应用程序在集合之间运行的时间。

### 2.5 内存占用量目标

如果已满足吞吐量和最大暂停时间目标，则垃圾收集器会减小堆的大小，直到无法满足其中一个目标（始终是吞吐量目标）。然后去解决未实现的目标。